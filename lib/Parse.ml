(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_gosu"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
]

let children_regexps : (string * Run.exp option) list = [
  "pat_0_3", None;
  "pat_dcaf70f", None;
  "any_character", None;
  "letter", None;
  "digit", None;
  "pat_dd18f70", None;
  "zerotoseven", None;
  "ident",
  Some (
    Seq [
      Token (Name "letter");
      Repeat (
        Alt [|
          Token (Name "digit");
          Token (Name "letter");
        |];
      );
    ];
  );
  "hexdigit",
  Some (
    Alt [|
      Token (Name "digit");
      Token (Name "pat_dcaf70f");
      Token (Name "pat_dd18f70");
    |];
  );
  "octalescape",
  Some (
    Alt [|
      Seq [
        Token (Literal "\\");
        Token (Name "pat_0_3");
        Token (Name "zerotoseven");
        Token (Name "zerotoseven");
      ];
      Seq [
        Token (Literal "\\");
        Token (Name "zerotoseven");
        Token (Name "zerotoseven");
      ];
      Seq [
        Token (Literal "\\");
        Token (Name "zerotoseven");
      ];
    |];
  );
  "id", Some (Token (Name "ident"););
  "idclassorinterfacetype", Some (Token (Name "ident"););
  "unicodeescape",
  Some (
    Seq [
      Token (Literal "\\u");
      Token (Name "hexdigit");
      Token (Name "hexdigit");
      Token (Name "hexdigit");
      Token (Name "hexdigit");
    ];
  );
  "classorinterfacetype",
  Some (
    Token (Name "idclassorinterfacetype");
  );
  "escapesequence",
  Some (
    Alt [|
      Seq [
        Token (Literal "\\");
        Alt [|
          Token (Literal "v");
          Token (Literal "a");
          Token (Literal "b");
          Token (Literal "t");
          Token (Literal "n");
          Token (Literal "f");
          Token (Literal "r");
          Token (Literal "\"");
          Token (Literal "'");
          Token (Literal "\\");
          Token (Literal "$");
          Token (Literal "<");
        |];
      ];
      Token (Name "unicodeescape");
      Token (Name "octalescape");
    |];
  );
  "type", Some (Token (Name "classorinterfacetype"););
  "stringliteral",
  Some (
    Alt [|
      Seq [
        Token (Literal "'");
        Repeat (
          Alt [|
            Token (Name "escapesequence");
            Token (Name "any_character");
          |];
        );
        Token (Literal "'");
      ];
      Seq [
        Token (Literal "\"");
        Repeat (
          Alt [|
            Token (Name "escapesequence");
            Token (Name "any_character");
          |];
        );
        Token (Literal "\"");
      ];
    |];
  );
  "typeliteral",
  Some (
    Seq [
      Token (Name "type");
      Opt (
        Seq [
          Token (Literal "&");
          Token (Name "type");
        ];
      );
    ];
  );
  "literal", Some (Token (Name "stringliteral"););
  "typeliteralexpr", Some (Token (Name "typeliteral"););
  "typeannotation",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "typeliteral");
    ];
  );
  "primaryexpr",
  Some (
    Alt [|
      Token (Name "literal");
      Token (Name "typeliteralexpr");
    |];
  );
  "unaryexprnotplusminus", Some (Token (Name "primaryexpr"););
  "unaryexpr", Some (Token (Name "unaryexprnotplusminus"););
  "typeasexpr", Some (Token (Name "unaryexpr"););
  "multiplicativeexpr", Some (Token (Name "typeasexpr"););
  "additiveexpr", Some (Token (Name "multiplicativeexpr"););
  "bitshiftexpr", Some (Token (Name "additiveexpr"););
  "intervalexpr", Some (Token (Name "bitshiftexpr"););
  "relationalexpr", Some (Token (Name "intervalexpr"););
  "equalityexpr", Some (Token (Name "relationalexpr"););
  "bitwiseandexpr", Some (Token (Name "equalityexpr"););
  "bitwisexorexpr", Some (Token (Name "bitwiseandexpr"););
  "bitwiseorexpr", Some (Token (Name "bitwisexorexpr"););
  "conditionalandexpr", Some (Token (Name "bitwiseorexpr"););
  "conditionalorexpr",
  Some (
    Token (Name "conditionalandexpr");
  );
  "conditionalexpr", Some (Token (Name "conditionalorexpr"););
  "expression", Some (Token (Name "conditionalexpr"););
  "localvarstatement",
  Some (
    Seq [
      Token (Literal "var");
      Token (Name "id");
      Opt (
        Token (Name "typeannotation");
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "namedargexpression",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "id");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "parenthexpr",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "argexpression",
  Some (
    Alt [|
      Token (Name "namedargexpression");
      Token (Name "expression");
    |];
  );
  "arguments",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "argexpression");
          Repeat (
            Seq [
              Token (Literal ", ");
              Token (Name "argexpression");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "indirectmemberaccessone",
  Some (
    Alt [|
      Token (Name "arguments");
    |];
  );
  "assignmentormethodcall",
  Some (
    Seq [
      Alt [|
        Token (Name "typeliteralexpr");
        Token (Name "parenthexpr");
        Token (Name "stringliteral");
      |];
      Repeat (
        Token (Name "indirectmemberaccessone");
      );
    ];
  );
  "statement",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "localvarstatement");
          Token (Name "assignmentormethodcall");
        |];
        Opt (
          Token (Literal ";");
        );
      ];
      Token (Literal ";");
    |];
  );
  "source_file",
  Some (
    Repeat (
      Token (Name "statement");
    );
  );
]

let trans_pat_0_3 ((kind, body) : mt) : CST.pat_0_3 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_dcaf70f ((kind, body) : mt) : CST.pat_dcaf70f =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_any_character ((kind, body) : mt) : CST.any_character =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_letter ((kind, body) : mt) : CST.letter =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_digit ((kind, body) : mt) : CST.digit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_dd18f70 ((kind, body) : mt) : CST.pat_dd18f70 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_zerotoseven ((kind, body) : mt) : CST.zerotoseven =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ident ((kind, body) : mt) : CST.ident =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_letter (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Digit (
                      trans_digit (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Letter (
                      trans_letter (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_hexdigit ((kind, body) : mt) : CST.hexdigit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Digit (
            trans_digit (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_dcaf70f (
            trans_pat_dcaf70f (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_dd18f70 (
            trans_pat_dd18f70 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_octalescape ((kind, body) : mt) : CST.octalescape =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BSLASH_pat_0_3_zero_zero (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_0_3 (Run.matcher_token v1),
                  trans_zerotoseven (Run.matcher_token v2),
                  trans_zerotoseven (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `BSLASH_zero_zero (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_zerotoseven (Run.matcher_token v1),
                  trans_zerotoseven (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `BSLASH_zero (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_zerotoseven (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_id ((kind, body) : mt) : CST.id =
  match body with
  | Children v ->
      trans_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_idclassorinterfacetype ((kind, body) : mt) : CST.idclassorinterfacetype =
  match body with
  | Children v ->
      trans_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_unicodeescape ((kind, body) : mt) : CST.unicodeescape =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_hexdigit (Run.matcher_token v1),
            trans_hexdigit (Run.matcher_token v2),
            trans_hexdigit (Run.matcher_token v3),
            trans_hexdigit (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_classorinterfacetype ((kind, body) : mt) : CST.classorinterfacetype =
  match body with
  | Children v ->
      trans_idclassorinterfacetype (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_escapesequence ((kind, body) : mt) : CST.escapesequence =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BSLASH_choice_v (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `V (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `A (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `B (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `T (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `N (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `F (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (6, v) ->
                      `R (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (7, v) ->
                      `DQUOT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (8, v) ->
                      `SQUOT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (9, v) ->
                      `BSLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (10, v) ->
                      `DOLLAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (11, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Unic (
            trans_unicodeescape (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Octa (
            trans_octalescape (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      trans_classorinterfacetype (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_stringliteral ((kind, body) : mt) : CST.stringliteral =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `SQUOT_rep_choice_esca_SQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Esca (
                            trans_escapesequence (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Any_char (
                            trans_any_character (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DQUOT_rep_choice_esca_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Esca (
                            trans_escapesequence (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Any_char (
                            trans_any_character (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_typeliteral ((kind, body) : mt) : CST.typeliteral =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      trans_stringliteral (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_typeliteralexpr ((kind, body) : mt) : CST.typeliteralexpr =
  match body with
  | Children v ->
      trans_typeliteral (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_typeannotation ((kind, body) : mt) : CST.typeannotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_typeliteral (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_primaryexpr ((kind, body) : mt) : CST.primaryexpr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit (
            trans_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Type (
            trans_typeliteralexpr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unaryexprnotplusminus ((kind, body) : mt) : CST.unaryexprnotplusminus =
  match body with
  | Children v ->
      trans_primaryexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_unaryexpr ((kind, body) : mt) : CST.unaryexpr =
  match body with
  | Children v ->
      trans_unaryexprnotplusminus (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_typeasexpr ((kind, body) : mt) : CST.typeasexpr =
  match body with
  | Children v ->
      trans_unaryexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_multiplicativeexpr ((kind, body) : mt) : CST.multiplicativeexpr =
  match body with
  | Children v ->
      trans_typeasexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_additiveexpr ((kind, body) : mt) : CST.additiveexpr =
  match body with
  | Children v ->
      trans_multiplicativeexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_bitshiftexpr ((kind, body) : mt) : CST.bitshiftexpr =
  match body with
  | Children v ->
      trans_additiveexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_intervalexpr ((kind, body) : mt) : CST.intervalexpr =
  match body with
  | Children v ->
      trans_bitshiftexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_relationalexpr ((kind, body) : mt) : CST.relationalexpr =
  match body with
  | Children v ->
      trans_intervalexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_equalityexpr ((kind, body) : mt) : CST.equalityexpr =
  match body with
  | Children v ->
      trans_relationalexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_bitwiseandexpr ((kind, body) : mt) : CST.bitwiseandexpr =
  match body with
  | Children v ->
      trans_equalityexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_bitwisexorexpr ((kind, body) : mt) : CST.bitwisexorexpr =
  match body with
  | Children v ->
      trans_bitwiseandexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_bitwiseorexpr ((kind, body) : mt) : CST.bitwiseorexpr =
  match body with
  | Children v ->
      trans_bitwisexorexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_conditionalandexpr ((kind, body) : mt) : CST.conditionalandexpr =
  match body with
  | Children v ->
      trans_bitwiseorexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_conditionalorexpr ((kind, body) : mt) : CST.conditionalorexpr =
  match body with
  | Children v ->
      trans_conditionalandexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_conditionalexpr ((kind, body) : mt) : CST.conditionalexpr =
  match body with
  | Children v ->
      trans_conditionalorexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      trans_conditionalexpr (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_localvarstatement ((kind, body) : mt) : CST.localvarstatement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_typeannotation (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_namedargexpression ((kind, body) : mt) : CST.namedargexpression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parenthexpr ((kind, body) : mt) : CST.parenthexpr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_argexpression ((kind, body) : mt) : CST.argexpression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Name (
            trans_namedargexpression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_arguments ((kind, body) : mt) : CST.arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_argexpression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_argexpression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_indirectmemberaccessone ((kind, body) : mt) : CST.indirectmemberaccessone =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Args (
            trans_arguments (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_assignmentormethodcall ((kind, body) : mt) : CST.assignmentormethodcall =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Type (
                  trans_typeliteralexpr (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pare (
                  trans_parenthexpr (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Stri (
                  trans_stringliteral (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                trans_indirectmemberaccessone (Run.matcher_token v)
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_loca_opt_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Loca (
                        trans_localvarstatement (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Assi (
                        trans_assignmentormethodcall (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      Run.repeat
        (fun v -> trans_statement (Run.matcher_token v))
        v
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  None

let translate_root src root_node =
  translate_tree src root_node trans_source_file

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

