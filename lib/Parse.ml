(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_gosu"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
  "line_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "semgrep_ellipsis", None;
  "modifiers",
  Some (
    Repeat1 (
      Alt [|
        Token (Literal "private");
        Token (Literal "internal");
        Token (Literal "protected");
        Token (Literal "public");
        Token (Literal "static");
        Token (Literal "abstract");
        Token (Literal "override");
        Token (Literal "final");
        Token (Literal "transient");
      |];
    );
  );
  "line_comment", None;
  "comment", None;
  "pat_3a2a380", None;
  "pat_dc28280", None;
  "id", None;
  "stringliteral",
  Some (
    Alt [|
      Seq [
        Token (Literal "'");
        Token (Name "pat_dc28280");
        Token (Literal "'");
      ];
      Seq [
        Token (Literal "\"");
        Token (Name "pat_3a2a380");
        Token (Literal "\"");
      ];
    |];
  );
  "usesstatement",
  Some (
    Seq [
      Token (Literal "uses");
      Token (Name "id");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "id");
        ];
      );
      Opt (
        Seq [
          Token (Literal ".");
          Token (Literal "*");
        ];
      );
      Repeat (
        Token (Literal ";");
      );
    ];
  );
  "namespacestatement",
  Some (
    Seq [
      Token (Name "id");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "id");
        ];
      );
      Repeat (
        Token (Literal ";");
      );
    ];
  );
  "type_identifier", Some (Token (Name "id"););
  "expression",
  Some (
    Alt [|
      Token (Name "stringliteral");
      Token (Name "id");
      Token (Name "semgrep_ellipsis");
    |];
  );
  "type",
  Some (
    Alt [|
      Token (Name "type_identifier");
    |];
  );
  "indirectmemberaccess1",
  Some (
    Alt [|
      Seq [
        Token (Literal ".");
        Token (Name "id");
      ];
      Seq [
        Token (Literal "(");
        Opt (
          Seq [
            Token (Name "expression");
            Repeat (
              Seq [
                Token (Literal ",");
                Token (Name "expression");
              ];
            );
          ];
        );
        Token (Literal ")");
      ];
    |];
  );
  "localvarstatement",
  Some (
    Seq [
      Token (Literal "var");
      Token (Name "id");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "fielddefn",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "var");
      Token (Name "id");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
      Opt (
        Seq [
          Token (Literal "as");
          Opt (
            Token (Literal "readonly");
          );
          Token (Name "id");
        ];
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "assignmentormethodcall",
  Some (
    Seq [
      Token (Name "id");
      Repeat (
        Token (Name "indirectmemberaccess1");
      );
    ];
  );
  "statement_",
  Some (
    Alt [|
      Token (Name "localvarstatement");
      Token (Name "assignmentormethodcall");
      Token (Name "semgrep_ellipsis");
    |];
  );
  "statement",
  Some (
    Seq [
      Token (Name "statement_");
      Opt (
        Token (Literal ";");
      );
    ];
  );
  "functiondefn",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "id");
      Token (Literal "(");
      Token (Literal ")");
      Opt (
        Seq [
          Token (Literal "{");
          Repeat (
            Token (Name "statement");
          );
          Token (Literal "}");
        ];
      );
    ];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "fielddefn");
      Token (Name "functiondefn");
      Token (Name "semgrep_ellipsis");
    |];
  );
  "classmembers",
  Some (
    Repeat1 (
      Token (Name "declaration");
    );
  );
  "classbody",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Token (Name "classmembers");
      );
      Token (Literal "}");
    ];
  );
  "gclass",
  Some (
    Seq [
      Token (Literal "class");
      Token (Name "id");
      Token (Name "classbody");
    ];
  );
  "start",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Literal "package");
          Token (Name "namespacestatement");
        ];
      );
      Repeat (
        Token (Name "usesstatement");
      );
      Opt (
        Token (Name "modifiers");
      );
      Alt [|
        Token (Name "gclass");
        Token (Name "functiondefn");
        Token (Name "statement");
      |];
    ];
  );
]

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_modifiers ((kind, body) : mt) : CST.modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Priv (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Inte (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (2, v) ->
              `Prot (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (3, v) ->
              `Public (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (4, v) ->
              `Static (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (5, v) ->
              `Abst (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (6, v) ->
              `Over (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (7, v) ->
              `Final (
                Run.trans_token (Run.matcher_token v)
              )
          | Alt (8, v) ->
              `Tran (
                Run.trans_token (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_line_comment ((kind, body) : mt) : CST.line_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_3a2a380 ((kind, body) : mt) : CST.pat_3a2a380 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_dc28280 ((kind, body) : mt) : CST.pat_dc28280 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_id ((kind, body) : mt) : CST.id =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_stringliteral ((kind, body) : mt) : CST.stringliteral =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `SQUOT_pat_dc28280_SQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_dc28280 (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DQUOT_pat_3a2a380_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_pat_3a2a380 (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_usesstatement ((kind, body) : mt) : CST.usesstatement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_id (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.repeat
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_namespacestatement ((kind, body) : mt) : CST.namespacestatement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_id (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_id (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.repeat
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_identifier ((kind, body) : mt) : CST.type_identifier =
  match body with
  | Children v ->
      trans_id (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Stri (
            trans_stringliteral (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_id (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Type_id (
            trans_type_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_indirectmemberaccess1 ((kind, body) : mt) : CST.indirectmemberaccess1 =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOT_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_id (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_opt_exp_rep_COMMA_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_expression (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                (match v with
                                | Seq [v0; v1] ->
                                    (
                                      Run.trans_token (Run.matcher_token v0),
                                      trans_expression (Run.matcher_token v1)
                                    )
                                | _ -> assert false
                                )
                              )
                              v1
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_localvarstatement ((kind, body) : mt) : CST.localvarstatement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fielddefn ((kind, body) : mt) : CST.fielddefn =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_id (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v1
                      ,
                      trans_id (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_assignmentormethodcall ((kind, body) : mt) : CST.assignmentormethodcall =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_id (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_indirectmemberaccess1 (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_statement_ ((kind, body) : mt) : CST.statement_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Loca (
            trans_localvarstatement (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Assi (
            trans_assignmentormethodcall (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_statement_ (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_functiondefn ((kind, body) : mt) : CST.functiondefn =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.repeat
                        (fun v -> trans_statement (Run.matcher_token v))
                        v1
                      ,
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Fiel (
            trans_fielddefn (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Func (
            trans_functiondefn (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_classmembers ((kind, body) : mt) : CST.classmembers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_declaration (Run.matcher_token v))
        v
  | Leaf _ -> assert false

let trans_classbody ((kind, body) : mt) : CST.classbody =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_classmembers (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_gclass ((kind, body) : mt) : CST.gclass =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_id (Run.matcher_token v1),
            trans_classbody (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_start ((kind, body) : mt) : CST.start =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_namespacestatement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            Run.repeat
              (fun v -> trans_usesstatement (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `Gclass (
                  trans_gclass (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func (
                  trans_functiondefn (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Stmt (
                  trans_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | "line_comment" ->
      (match translate_tree src node trans_line_comment with
      | None -> None
      | Some x -> Some (`Line_comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_start

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

