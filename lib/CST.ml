(* Generated by ocaml-tree-sitter. *)
(*
   gosu grammar

   entrypoint: start
*)

open! Sexplib.Conv
open Tree_sitter_run

type modifiers =
  [
      `Priv of Token.t (* "private" *)
    | `Inte of Token.t (* "internal" *)
    | `Prot of Token.t (* "protected" *)
    | `Public of Token.t (* "public" *)
    | `Static of Token.t (* "static" *)
    | `Abst of Token.t (* "abstract" *)
    | `Over of Token.t (* "override" *)
    | `Final of Token.t (* "final" *)
    | `Tran of Token.t (* "transient" *)
  ]
    list (* one or more *)

type pat_3a2a380 = Token.t (* pattern "[^\"\\\\]+" *)

type pat_dc28280 = Token.t (* pattern "[^'\\\\]+" *)

type id = Token.t

type stringliteral = [
    `SQUOT_pat_dc28280_SQUOT of (
        Token.t (* "'" *) * pat_dc28280 * Token.t (* "'" *)
    )
  | `DQUOT_pat_3a2a380_DQUOT of (
        Token.t (* "\"" *) * pat_3a2a380 * Token.t (* "\"" *)
    )
]

type expression = [ `Stri of stringliteral ]

type namespacestatement = (
    id (*tok*)
  * (Token.t (* "." *) * id (*tok*)) list (* zero or more *)
  * Token.t (* ";" *) list (* zero or more *)
)

type usesstatement = (
    Token.t (* "uses" *)
  * id (*tok*)
  * (Token.t (* "." *) * id (*tok*)) list (* zero or more *)
  * (Token.t (* "." *) * Token.t (* "*" *)) option
  * Token.t (* ";" *) list (* zero or more *)
)

type type_ = [ `Type_id of id (*tok*) ]

type indirectmemberaccess1 = [
    `DOT_id of (Token.t (* "." *) * id (*tok*))
  | `LPAR_opt_exp_rep_COMMA_exp_RPAR of (
        Token.t (* "(" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
]

type localvarstatement = (
    Token.t (* "var" *)
  * id (*tok*)
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "=" *) * expression) option
)

type assignmentormethodcall = (
    id (*tok*)
  * indirectmemberaccess1 list (* zero or more *)
)

type statement = (
    [ `Loca of localvarstatement | `Assi of assignmentormethodcall ]
  * Token.t (* ";" *) option
)

type declaration = [
    `Fiel of (
        modifiers option
      * Token.t (* "var" *)
      * id (*tok*)
      * (Token.t (* ":" *) * type_) option
      * (Token.t (* "as" *) * Token.t (* "readonly" *) option * id (*tok*))
          option
      * (Token.t (* "=" *) * expression) option
      * Token.t (* ";" *) option
    )
  | `Func of (
        Token.t (* "function" *)
      * id (*tok*)
      * Token.t (* "(" *)
      * Token.t (* ")" *)
      * (
            Token.t (* "{" *)
          * statement list (* zero or more *)
          * Token.t (* "}" *)
        )
          option
    )
  | `Semg_ellips of Token.t (* "..." *)
]

type classmembers = declaration list (* one or more *)

type classbody = (
    Token.t (* "{" *)
  * classmembers option
  * Token.t (* "}" *)
)

type gclass = (Token.t (* "class" *) * id (*tok*) * classbody)

type start = (
    (Token.t (* "package" *) * namespacestatement) option
  * usesstatement list (* zero or more *)
  * modifiers option
  * [ `Gclass of gclass ]
)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type line_comment (* inlined *) = Token.t (* pattern \/\/[^\n\r]* *)

type comment (* inlined *) = Token.t (* pattern \/\*([^\*]|(\*[^\/]))*\*\/ *)

type digit (* inlined *) = Token.t (* pattern [0-9] *)

type type_identifier (* inlined *) = id (*tok*)

type fielddefn (* inlined *) = (
    modifiers option
  * Token.t (* "var" *)
  * id (*tok*)
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "as" *) * Token.t (* "readonly" *) option * id (*tok*))
      option
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *) option
)

type functiondefn (* inlined *) = (
    Token.t (* "function" *)
  * id (*tok*)
  * Token.t (* "(" *)
  * Token.t (* ")" *)
  * (
        Token.t (* "{" *)
      * statement list (* zero or more *)
      * Token.t (* "}" *)
    )
      option
)

type extra = [
    `Comment of Loc.t * comment
  | `Line_comment of Loc.t * line_comment
]

type extras = extra list
