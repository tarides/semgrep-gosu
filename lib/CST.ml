(* Generated by ocaml-tree-sitter. *)
(*
   gosu grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type digit = Token.t (* pattern [0-9] *)

type pat_0_3 = Token.t (* pattern 0-3 *)

type letter = Token.t (* pattern [A-Za-z_$] *)

type pat_dcaf70f = Token.t (* pattern [A-F] *)

type zerotoseven = Token.t (* pattern [0-7] *)

type pat_dd18f70 = Token.t (* pattern [a-f] *)

type any_character = Token.t (* pattern . *)

type ident = (
    letter (*tok*)
  * [ `Digit of digit (*tok*) | `Letter of letter (*tok*) ]
      list (* zero or more *)
)

type octalescape = [
    `BSLASH_pat_0_3_zero_zero of (
        Token.t (* "\\" *) * pat_0_3 * zerotoseven (*tok*)
      * zerotoseven (*tok*)
    )
  | `BSLASH_zero_zero of (
        Token.t (* "\\" *) * zerotoseven (*tok*) * zerotoseven (*tok*)
    )
  | `BSLASH_zero of (Token.t (* "\\" *) * zerotoseven (*tok*))
]

type hexdigit = [
    `Digit of digit (*tok*)
  | `Pat_dcaf70f of pat_dcaf70f
  | `Pat_dd18f70 of pat_dd18f70
]

type id = ident

type idclassorinterfacetype = ident

type classorinterfacetype = idclassorinterfacetype

type escapesequence = [
    `BSLASH_choice_v of (
        Token.t (* "\\" *)
      * [
            `V of Token.t (* "v" *)
          | `A of Token.t (* "a" *)
          | `B of Token.t (* "b" *)
          | `T of Token.t (* "t" *)
          | `N of Token.t (* "n" *)
          | `F of Token.t (* "f" *)
          | `R of Token.t (* "r" *)
          | `DQUOT of Token.t (* "\"" *)
          | `SQUOT of Token.t (* "'" *)
          | `BSLASH of Token.t (* "\\" *)
          | `DOLLAR of Token.t (* "$" *)
          | `LT of Token.t (* "<" *)
        ]
    )
  | `Unic of (
        Token.t (* "\\u" *) * hexdigit * hexdigit * hexdigit * hexdigit
    )
  | `Octa of octalescape
]

type type_ = classorinterfacetype

type anon_choice_esca_b61eefe = [
    `Esca of escapesequence
  | `Any_char of any_character (*tok*)
]

type typeliteral = (type_ * (Token.t (* "&" *) * type_) option)

type stringliteral = [
    `SQUOT_rep_choice_esca_SQUOT of (
        Token.t (* "'" *)
      * anon_choice_esca_b61eefe list (* zero or more *)
      * Token.t (* "'" *)
    )
  | `DQUOT_rep_choice_esca_DQUOT of (
        Token.t (* "\"" *)
      * anon_choice_esca_b61eefe list (* zero or more *)
      * Token.t (* "\"" *)
    )
]

type typeliteralexpr = typeliteral

type literal = stringliteral

type typeannotation = (Token.t (* ":" *) * typeliteralexpr)

type primaryexpr = [ `Lit of literal | `Type of typeliteralexpr ]

type unaryexprnotplusminus = primaryexpr

type unaryexpr = unaryexprnotplusminus

type typeasexpr = unaryexpr

type multiplicativeexpr = typeasexpr

type additiveexpr = multiplicativeexpr

type bitshiftexpr = additiveexpr

type intervalexpr = bitshiftexpr

type relationalexpr = intervalexpr

type equalityexpr = relationalexpr

type bitwiseandexpr = equalityexpr

type bitwisexorexpr = bitwiseandexpr

type bitwiseorexpr = bitwisexorexpr

type conditionalandexpr = bitwiseorexpr

type conditionalorexpr = conditionalandexpr

type conditionalexpr = conditionalorexpr

type expression = conditionalexpr

type parenthexpr = (Token.t (* "(" *) * expression * Token.t (* ")" *))

type localvarstatement = (
    Token.t (* "var" *)
  * id
  * typeannotation option
  * (Token.t (* "=" *) * expression) option
)

type argexpression = [
    `Name of (Token.t (* ":" *) * id * Token.t (* "=" *) * expression)
  | `Exp of expression
]

type indirectmemberaccessone = [
  `Args of (
      Token.t (* "(" *)
    * (
          argexpression
        * (Token.t (* ", " *) * argexpression) list (* zero or more *)
      )
        option
    * Token.t (* ")" *)
  )
]

type assignmentormethodcall = (
    [ `Type of typeliteralexpr | `Pare of parenthexpr | `Stri of literal ]
  * indirectmemberaccessone list (* zero or more *)
)

type statement = [
    `Choice_loca_opt_SEMI of (
        [ `Loca of localvarstatement | `Assi of assignmentormethodcall ]
      * Token.t (* ";" *) option
    )
  | `SEMI of Token.t (* ";" *)
]

type source_file = statement list (* zero or more *)

type unicodeescape (* inlined *) = (
    Token.t (* "\\u" *) * hexdigit * hexdigit * hexdigit * hexdigit
)

type namedargexpression (* inlined *) = (
    Token.t (* ":" *) * id * Token.t (* "=" *) * expression
)

type arguments (* inlined *) = (
    Token.t (* "(" *)
  * (
        argexpression
      * (Token.t (* ", " *) * argexpression) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type extra

type extras = extra list
