(* Generated by ocaml-tree-sitter. *)
(*
   gosu grammar

   entrypoint: start
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_3a2a380 = Token.t (* pattern "[^\"\\\\]+" *)

type modifiers =
  [
      `Priv of Token.t (* "private" *)
    | `Inte of Token.t (* "internal" *)
    | `Prot of Token.t (* "protected" *)
    | `Public of Token.t (* "public" *)
    | `Static of Token.t (* "static" *)
    | `Abst of Token.t (* "abstract" *)
    | `Over of Token.t (* "override" *)
    | `Final of Token.t (* "final" *)
    | `Tran of Token.t (* "transient" *)
  ]
    list (* one or more *)

type additiveop = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `QMARKPLUS of Token.t (* "?+" *)
  | `QMARKDASH of Token.t (* "?-" *)
]

type id = Token.t

type pat_dc28280 = Token.t (* pattern "[^'\\\\]+" *)

type stringliteral = [
    `SQUOT_pat_dc28280_SQUOT of (
        Token.t (* "'" *) * pat_dc28280 * Token.t (* "'" *)
    )
  | `DQUOT_pat_3a2a380_DQUOT of (
        Token.t (* "\"" *) * pat_3a2a380 * Token.t (* "\"" *)
    )
]

type type_ = [ `Type_id of id (*tok*) ]

type namespacestatement = (
    id (*tok*)
  * (Token.t (* "." *) * id (*tok*)) list (* zero or more *)
  * Token.t (* ";" *) list (* zero or more *)
)

type usesstatement = [
    `Uses_id_rep_DOT_id_opt_DOT_STAR_rep_SEMI of (
        Token.t (* "uses" *)
      * id (*tok*)
      * (Token.t (* "." *) * id (*tok*)) list (* zero or more *)
      * (Token.t (* "." *) * Token.t (* "*" *)) option
      * Token.t (* ";" *) list (* zero or more *)
    )
  | `Semg_ellips of Token.t (* "..." *)
]

type additiveexpr = (expression * additiveop * expression)

and arguments = (
    Token.t (* "(" *)
  * (expression * (Token.t (* "," *) * expression) list (* zero or more *))
      option
  * Token.t (* ")" *)
)

and expression = [
    `Choice_stri_rep_indi1 of (
        [
            `Stri of stringliteral
          | `Id of id (*tok*)
          | `Addi of additiveexpr
          | `Newe of newexpr
        ]
      * indirectmemberaccess1 list (* zero or more *)
    )
  | `Semg_ellips of Token.t (* "..." *)
]

and indirectmemberaccess1 = [
    `DOT_id of (Token.t (* "." *) * id (*tok*))
  | `Args of arguments
]

and newexpr = (Token.t (* "new" *) * id (*tok*) * arguments)

type parameterdeclaration = (
    id (*tok*)
  * [
        `COLON_type_opt_EQ_exp of (
            Token.t (* ":" *)
          * type_
          * (Token.t (* "=" *) * expression) option
        )
      | `EQ_exp of (Token.t (* "=" *) * expression)
    ]
      option
)

type parameterdeclarationlist = (
    parameterdeclaration
  * (Token.t (* "," *) * parameterdeclaration) list (* zero or more *)
)

type statement_ = [
    `Loca of (
        Token.t (* "var" *)
      * id (*tok*)
      * (Token.t (* ":" *) * type_) option
      * (Token.t (* "=" *) * expression) option
    )
  | `Assi of (
        [ `Id of id (*tok*) | `Newe of newexpr ]
      * indirectmemberaccess1 list (* zero or more *)
    )
  | `Semg_ellips of Token.t (* "..." *)
]

type statement = (statement_ * Token.t (* ";" *) option)

type functiondefn = (
    Token.t (* "function" *)
  * id (*tok*)
  * Token.t (* "(" *)
  * parameterdeclarationlist option
  * Token.t (* ")" *)
  * (
        Token.t (* "{" *)
      * statement list (* zero or more *)
      * Token.t (* "}" *)
    )
      option
)

type declaration = [
    `Fiel of (
        modifiers option
      * Token.t (* "var" *)
      * id (*tok*)
      * (Token.t (* ":" *) * type_) option
      * (Token.t (* "as" *) * Token.t (* "readonly" *) option * id (*tok*))
          option
      * (Token.t (* "=" *) * expression) option
      * Token.t (* ";" *) option
    )
  | `Func of functiondefn
  | `Semg_ellips of Token.t (* "..." *)
]

type classmembers = declaration list (* one or more *)

type classbody = (
    Token.t (* "{" *)
  * classmembers option
  * Token.t (* "}" *)
)

type gclass = (Token.t (* "class" *) * id (*tok*) * classbody)

type start = (
    (Token.t (* "package" *) * namespacestatement) option
  * usesstatement list (* zero or more *)
  * modifiers option
  * [ `Gclass of gclass | `Func of functiondefn | `Stmt of statement ]
)

type line_comment (* inlined *) = Token.t (* pattern \/\/[^\n\r]* *)

type comment (* inlined *) = Token.t (* pattern \/\*([^\*]|(\*[^\/]))*\*\/ *)

type digit (* inlined *) = Token.t (* pattern [0-9] *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type type_identifier (* inlined *) = id (*tok*)

type fielddefn (* inlined *) = (
    modifiers option
  * Token.t (* "var" *)
  * id (*tok*)
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "as" *) * Token.t (* "readonly" *) option * id (*tok*))
      option
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *) option
)

type localvarstatement (* inlined *) = (
    Token.t (* "var" *)
  * id (*tok*)
  * (Token.t (* ":" *) * type_) option
  * (Token.t (* "=" *) * expression) option
)

type assignmentormethodcall (* inlined *) = (
    [ `Id of id (*tok*) | `Newe of newexpr ]
  * indirectmemberaccess1 list (* zero or more *)
)

type extra = [
    `Comment of Loc.t * comment
  | `Line_comment of Loc.t * line_comment
]

type extras = extra list
